#!/bin/bash

# Manage gpg encrypted files in pass .password-store type directory

# Halt on error
set -e


# Print error message and exit
error()
{
  msg="$1"
  exit_code="$2"

  echo "Error: $1" >&2

  [ "$exit_code" = "" ] && exit_code=1

  exit $exit_code
}


# Print help
help ()
{
  echo help
}

# Print usage message
usage ()
{
  echo -e "Usage: overtake [add <file>|copy [file]|delete [file]|edit [file]|help|list [--full]|show [file]]"
  exit 1
}


# Do we sync git?
sync_git()
{
  if [ "$SYNC_GIT" = "yes" ]; then
    if command -v git &> /dev/null; then
      return 0
    else
      error "SYNC_GIT=yes, but git command not found"
    fi
  fi
  return 1
}


# Verify if password store dir is a git repo
is_git_repo()
{
  if [ -d "$PASSWORD_STORE_DIR/.git" ]; then
    return 0
  fi

  return 1
}


# Check if git has remotes
git_has_remote()
{
  if is_git_repo; then
    cd "$PASSWORD_STORE_DIR"
    if [[ $(git branch -r) ]]; then
      return 0
    fi
  fi

  return 1
}


# If git repo and has remotes, do git pull
git_pull()
{
  sync_git || return 0

  # If git repo, make sure up to date
  if git_has_remote; then
    cd "$PASSWORD_STORE_DIR"
    git pull || error "Unable to pull remote git repo"
  fi
}


# If git repo git add file and commit it
git_commit_all()
{
  sync_git || return 0

  if is_git_repo; then
    cd "$PASSWORD_STORE_DIR"
    git add --all || error "Git add failed"
    git commit -m 'Added' || error "Git commit failed"

    git_push
  fi
}


# If git repo and it has remote then do git push
git_push()
{
    if git_has_remote; then
      cd "$PASSWORD_STORE_DIR"
      git push || error "Unable to push to remote git repo"
    fi
}


# Return absolute file path for a file
absolute_file_path()
{
  file_path="$1"

  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # If file path does not start with a / it is relative and needs making absolute
  if [[ "$file_path" != /* ]]; then
    file_path="$PASSWORD_STORE_DIR/$file_path"
  fi

  echo "$file_path"
}


# Return file path relative to password store dir for a file
relative_file_path()
{
  file_path="$1"
  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # Strip password dir
  file_path="${file_path#"$PASSWORD_STORE_DIR"/}"

  echo "$file_path"
}


# List all gpg files in password store
list_pretty_paths()
{
  list_absolute_paths | sed 's#^'$PASSWORD_STORE_DIR'/## ; s/\.gpg$//'
}


list_absolute_paths()
{
  find "$PASSWORD_STORE_DIR" -type f -name '*.gpg'
}


# List as tree
list_tree()
{
  if command -v tree &> /dev/null; then
    tree -P '*.gpg' "$PASSWORD_STORE_DIR" | sed 's/\.gpg$//'
  else
    echo "Command tree not found, it is often in moreutils"
  fi
}

# Try to add new encrypted file with newly generated passphrase, update git if applicable
add()
{
  # If path contains PASSWORD_STORE_DIR, remove it, so we can handle both relative and absolute paths
  file="$1"

  file_path_absolute="$(absolute_file_path "$file")"
  file_path_relative="$(relative_file_path "$file")"

  [ -e "$file_path_absolute" ] && error "Unable to create $file_path_absolute, it already exists"

  # Create directories if need be
  # TODO trap ERR to delete dirs if things go south
  file_directories="${file_path_absolute%/*}"
  mkdir -p "$file_directories" || error "Unable to create $file_directories"

  git_pull

  if [[ $(type -t OVERTAKE_EXT_template) == function ]]; then
    OVERTAKE_EXT_template | edit_then_encrypt "$file_path_absolute" "-"
  else
    edit_then_encrypt "$file_path_absolute"
  fi

  git_commit_all
}


# Decrypt, edit and reencrypt file, file passed as argument or selected from fzf
edit()
{
  file="$(get_file_path "$1")"

  [ "$file" = "" ] && exit 0

  git_pull

  gpg_decrypt_file "$file" | edit_then_encrypt "$file" -

  git_commit_all
}


# Allow user to edit data and save it encrypted to disk
# Must be callable in two ways
# 1. With just one argument specifying the path to save data to
#    E.g edit_then_encrypt "/tmp/myfile.gpg"
# 2. With two arguments, the path to save data to and "-" indicating stdin, and data piped into the funtion
#    E.g echo "My content" | edit_then_encrypt "/tmp/myfile.gpg" "-"
edit_then_encrypt()
{
  save_path="$1"
  stdin_arg="$2"
  if [ "$stdin_arg" = "-" ]; then
    cmd="cat"
  else
    cmd="echo ''"
  fi

  $cmd | GPG_KEY="$PASSWORD_STORE_KEY" GPG_ENCRYPTED_FILE="$save_path" vim --not-a-term -u "$OVERTAKE_DIR/overtake_vimrc" -
}


# Take path and make it absolute, if no path get user to choose
get_file_path()
{
  file="$1"

  if [ "$2" = "" ]; then
    prompt="Password store $PASSWORD_STORE_DIR using key $PASSWORD_STORE_KEY"
  else
    prompt="$2"
  fi

  # If no argument, get user to select a file to edit
  if [ "$file" = "" ]; then
    file="$(list_pretty_paths | fzf "--header=$prompt" --exact)"
    [ "$file" = "" ] && return 0
  fi

  file_path_absolute="$(absolute_file_path "$file")"

  [ -f "$file_path_absolute" ] || error "Path $file is not valid"

  echo "$file_path_absolute"
}


# Print decrypted content
show()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] || gpg_decrypt_file "$file"
}


# Delete key
delete()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  [ -e "$file" ] || error "File $file does not exist"

  git_pull

  rm "$file"

  git_commit_all
}


# Copy key to clipboard
copy()
{
  file="$(get_file_path "$1")"

  # If config file has defined a function for clipboard, use it to copy
  if [[ $(type -t OVERTAKE_EXT_clipboard) == function ]]; then
    show "$file" | OVERTAKE_EXT_clipboard
  # Else emulate pass behaviour by just copying 1st line to clipboard
  else
    show "$file" | head -n1 | tr -d '\n' | xsel --clipboard
  fi
}


gpg_decrypt_file ()
{
  file="$1"
  [ -e "$file" ] || error "File $file not found, unable to decrypt"
  gpg --quiet --decrypt "$file" || error "Unable to decrypt $file, perhaps key passphrase is not cached by gpg-agent yet?"
}


# Exit if no args
[ $# -lt 1 ] && usage

# Use pass default password store path, or get from environment variable
CONFIG_FILE="$HOME/.config/overtake.conf"
PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
PASSWORD_STORE_KEY="${PASSWORD_STORE_KEY:-your@gpg.key}"
SYNC_GIT="${SYNC_GIT:-no}"


# Load config
[ -e "$CONFIG_FILE" ] && source "$CONFIG_FILE"

# Set OVERTAKE_DIR, where the source is found
if [ "$OVERTAKE_DIR" = "" ]; then
  if command -v realpath &> /dev/null; then
    OVERTAKE_DIR="$(realpath "$BASH_SOURCE")"
  else
    OVERTAKE_DIR="$BASH_SOURCE"
    echo "Command realpath from Coreutils not found. Assuming overtake is installed at $OVERTAKE_DIR, but if symlinks are used this may not be correct and you may need to set OVERTAKE_DIR in overtake.conf."
  fi
  OVERTAKE_DIR="${OVERTAKE_DIR%/*}"
fi

# Remove any trailing slash
PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR%/}"

[ -d "$PASSWORD_STORE_DIR" ] || error "No directory at $PASSWORD_STORE_DIR"

mode="$1"

case $mode in
  add)
    if [ $# -ne 2 ]; then
      echo "Error: Expected file argument"
      usage
    fi
    add "$2"
  ;;
  edit)
    case $# in
      1) edit ;;
      2) edit "$2" ;;
      *) usage ;;
    esac
  ;;
  delete)
     case $# in
      1) delete ;;
      2) delete "$2" ;;
      *) usage ;;
    esac
  ;;
  list)
    case $# in
      1) list_pretty_paths ;;
      2)
        if [ "$2" = "--full" ]; then
          list_absolute_paths
        elif [ "$2" = "--tree" ]; then
          list_tree
        else
          list_pretty_paths
        fi
      ;;
      *) usage ;;
    esac
  ;;
  show)
    case $# in
      1) show ;;
      2) show "$2" ;;
      *) usage ;;
    esac
  ;;
  copy)
    case $# in
      1) copy ;;
      2) copy "$2" ;;
      *) usage ;;
    esac
  ;;
  help)
    help
  ;;
  *)
    usage
  ;;
esac

