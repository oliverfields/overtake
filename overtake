#!/bin/bash

# Manage gpg encrypted files in pass .password-store type directory

# Halt on error
set -e


# Print error message and exit
error()
{
  msg="$1"
  exit_code="$2"

  echo -e "Error: $1" >&2

  [ "$exit_code" = "" ] && exit_code=1

  exit $exit_code
}


# Print help
help()
{
  echo -e '
Manage directory of GPG encrypted files.

The argument [file] is optional, if not specified a file selection dialogue will be opened.

	\e[1madd\e[0m <file>
		Create new file in $PASSWORD_STORE_DIR, path must be relative (not start with /). If path contains directories, these will also be created

		\e[1mExample\e[0m
			$ overtake add gnupg.org/login
			Creates $PASSWORD_STORE_DIR/gnupg directory if not already created, and login.gpg encrypted file

	\e[1mcopy\e[0m [file]
		Copies decrypted contents to clipboard

	\e[1mdelete\e[0m [file]
		Deletes file from $PASSWORD_STORE_DIR

	\e[1medit\e[0m [file]
		Decrypt file, open in vi for editing and encrypt contents back to <file>

	\e[1mlist\e[0m [--full|--tree]
		List .gpg files in $PASSWORD_STORE_DIR, --full lists full path, --tree shows tree view

	\e[1mshow\e[0m [file]
		Print decrypted file to terminal

	\e[1mhelp\e[0m
		This text
' | fmt

  usage
}

# Print usage message
usage()
{
  echo -e "Usage: overtake [add <file>|copy [file]|delete [file]|edit [file]|help|list [--full]|show [file]]"
  exit 1
}


# For all git repositories in password store, run batch commands
batch_repos_cmd()
{
  if [ "$SYNC_GIT" != "yes" ]; then
    return 0
  fi

  if ! command -v git &> /dev/null; then
      error "git command not found"
  fi

  batch_cmd="$1"

  # Check args
  if [ "$batch_cmd" != "pull" ] && [ "$batch_cmd" != "commitall" ]; then
    error "No valid batch command supplied for batch_command_repos $batch_cmd"
  fi


  # Find all git repos in password store
  for repo in $(find "$PASSWORD_STORE_DIR" -type d -name '.git'); do

    git_dir="${repo%/*}"

    cd "$git_dir" || error "Unable to cd to $git_dir"

    if [[ $(git branch -r) ]]; then
      has_remote="yes"
    else
      has_remote="no"
    fi

    case $batch_cmd in
      pull)
        if [ "$has_remote" = "yes" ]; then
          git pull --quiet || error "Unable to pull repo $repo remote"
        fi
      ;;
      commitall)
        # Check if changes, if so commit and push
        if [ -n "$(git status --porcelain)" ]; then
          git add --all || error "Git add failed on repo $repo"
          git commit -m 'Overtake sync' --quiet || error "Git commit failed on repo $repo"

          if [ "$has_remote" = "yes" ]; then
            git push --quiet || error "Unable to push to remote git repo $repo"
          fi
        fi
      ;;
    esac
  done
}


# Return absolute file path for a file
absolute_file_path()
{
  file_path="$1"

  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # If file path does not start with a / it is relative and needs making absolute
  if [[ "$file_path" != /* ]]; then
    file_path="$PASSWORD_STORE_DIR/$file_path"
  fi

  echo "$file_path"
}


# Return file path relative to password store dir for a file
relative_file_path()
{
  file_path="$1"
  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # Strip password dir
  file_path="${file_path#"$PASSWORD_STORE_DIR"/}"

  echo "$file_path"
}


# List all gpg files in password store
list_pretty_paths()
{
  list_absolute_paths | sed 's#^'$PASSWORD_STORE_DIR'/## ; s/\.gpg$//'
}


list_absolute_paths()
{
  find "$PASSWORD_STORE_DIR" -type f -name '*.gpg'
}


# List as tree
list_tree()
{
  if command -v tree &> /dev/null; then
    tree "$PASSWORD_STORE_DIR" | sed 's/\.gpg$//'
  else
    echo "Command tree not found, it is often in moreutils"
  fi
}

# Try to add new encrypted file with newly generated passphrase, update git if applicable
add()
{
  # If path contains PASSWORD_STORE_DIR, remove it, so we can handle both relative and absolute paths
  file="$1"

  file_path_absolute="$(absolute_file_path "$file")"
  file_path_relative="$(relative_file_path "$file")"

  [ -e "$file_path_absolute" ] && error "Unable to create $file_path_absolute, it already exists"

  # Create directories if need be
  # TODO trap ERR to delete dirs if things go south
  file_directories="${file_path_absolute%/*}"
  mkdir -p "$file_directories" || error "Unable to create $file_directories"

  batch_repos_cmd pull

  gpg_recipients="$(get_gpg_recipients "$file_path_absolute")"

  if [[ $(type -t OVERTAKE_EXT_template) == function ]]; then
    OVERTAKE_EXT_template | edit_then_encrypt "$file_path_absolute" "$gpg_recipients" "-"
  else
    edit_then_encrypt "$file_path_absolute" "$gpg_recipients"
  fi

  batch_repos_cmd commitall
}


# Decrypt, edit and reencrypt file, file passed as argument or selected from fzf
edit()
{
  file="$(get_file_path "$1")"

  [ "$file" = "" ] && exit 0

  batch_repos_cmd pull

  gpg_recipients="$(get_gpg_recipients "$file")"

  gpg_decrypt_file "$file" | edit_then_encrypt "$file" "$gpg_recipients" "-"

  batch_repos_cmd commitall
}


# Allow user to edit data and save it encrypted to disk
# Must be callable in two ways
# 1. With path to save data to and the recipients (CSV if multiple) to encrypt to
#    E.g edit_then_encrypt "/tmp/myfile.gpg" "your@email.com,another@email.com"
# 2. With the path to save to, recipients andand "-" indicating stdin, and data piped into the funtion
#    E.g echo "My content" | edit_then_encrypt "/tmp/myfile.gpg" "me@you.com" "-"
edit_then_encrypt()
{
  save_path="$1"
  recipients="$2"
  stdin_arg="$3"

  if [ "$stdin_arg" = "-" ]; then
    cmd="cat"
  else
    cmd="echo ''"
  fi

  $cmd | GPG_RECIPIENTS="$recipients" GPG_ENCRYPTED_FILE="$save_path" vim --not-a-term -u "$OVERTAKE_DIR/overtake_vimrc" -
}


# Given a path look up until find a .gpg-id file, this contains the recipients, one per line
get_gpg_recipients()
{
  file="$1"
  dir_path="${file%/*}"
  gpg_id_file=""

  cd "$dir_path"

  # Go up directory tree until find a valid .gpg-id file, quit if we gone passed the password store
  while [ "$PWD" != "${PASSWORD_STORE_DIR%/*}" ]; do
    if [ -f "$PWD/.gpg-id" ]; then
      gpg_id_file="$PWD/.gpg-id"
      break
    fi
    cd ..
  done

  if [ "$gpg_id_file" != "" ]; then
    recipients_string=$(paste -s -d ' ' "$gpg_id_file")
  fi

  # Add recipients from settings also
  recipients_string="$PASSWORD_STORE_DEFAULT_RECIPIENTS $recipients_string"
  recipients_string="$PASSWORD_STORE_KEY $recipients_string"

  # Need to tidy up, remove any duplicates and verify that have recipient keys
  recipients_tmp_array=( $recipients_string )

  [ ${#recipients_tmp_array[@]} -eq 0 ] && error "No gpg recipients defined in PASSWORD_STORE_DIR_DEFAULT_RECIPIENTS, .gpg-id files or PASSWORD_STORE_KEY"

  # Use associative array to weed out duplicates
  declare -A recipients
  for r in "${recipients_tmp_array[@]}"; do
    recipients["$r"]="NULL"
  done

  missing_keys=()

  # Check we have gpg public keys for the recipients
  for key in "${!recipients[@]}"; do
    if gpg --list-keys "$key" &> /dev/null; then
      recipients[$key]="yes"
    else
      recipients[$key]="no"
      missing_keys+=($key)
    fi
  done


  if [ ${#missing_keys[@]} -ne 0 ]; then
    missing_keys_string="${missing_keys[@]}"
    missing_keys_string="${missing_keys_string// /, }"
    error "No public keys match $missing_keys_string, unable to process $file"
  fi

  recipient_keys=""
  for key in "${!recipients[@]}"; do
    recipient_keys="$recipient_keys $key"
  done
  recipient_keys="${recipient_keys# }"

  echo -n "$recipient_keys"
}


# Take path and make it absolute, if no path get user to choose
get_file_path()
{
  file="$1"

  if [ "$2" = "" ]; then
    prompt="Password store $PASSWORD_STORE_DIR using key $PASSWORD_STORE_DEFAULT_RECIPIENTS"
  else
    prompt="$2"
  fi

  # If no argument, get user to select a file to edit
  if [ "$file" = "" ]; then
    file="$(list_pretty_paths | fzf "--header=$prompt" --exact)"
    [ "$file" = "" ] && return 0
  fi

  file_path_absolute="$(absolute_file_path "$file")"

  [ -f "$file_path_absolute" ] || error "Path $file is not valid"

  echo "$file_path_absolute"
}


# Print decrypted content
print_decrypted_content()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  gpg_decrypt_file "$file"
}


show()
{
  print_decrypted_content "$1"
  echo ""
  read -p "Press any key to clear terminal and continue.." key
  clear
}


# Delete key
delete()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  [ -e "$file" ] || error "File $file does not exist"

  batch_repos_cmd pull

  rm "$file"

  batch_repos_cmd commitall
}


# Copy key to clipboard
copy()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  # If config file has defined a function for clipboard, use it to copy
  if [[ $(type -t OVERTAKE_EXT_clipboard) == function ]]; then
    print_decrypted_content "$file" | OVERTAKE_EXT_clipboard
  # Else emulate pass behaviour by just copying 1st line to clipboard
  else
    print_decrypted_content "$file" | head -n1 | tr -d '\n' | xsel --clipboard
  fi
}


gpg_decrypt_file()
{
  file="$1"
  [ -e "$file" ] || error "File $file not found, unable to decrypt"
  gpg --quiet --decrypt "$file" || error "Unable to decrypt $file, perhaps key passphrase is not cached by gpg-agent yet?"
}


# Exit if no args
[ $# -lt 1 ] && usage

# Use pass default password store path, or get from environment variable
CONFIG_FILE="$HOME/.config/overtake.conf"
PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR:-$HOME/.password-store}"
PASSWORD_STORE_DEFAULT_RECIPIENTS="${PASSWORD_STORE_KEY:-your@gpg.key}"
SYNC_GIT="${SYNC_GIT:-no}"


# Load config
[ -e "$CONFIG_FILE" ] && source "$CONFIG_FILE"

# Set OVERTAKE_DIR, where the source is found
if [ "$OVERTAKE_DIR" = "" ]; then
  if command -v realpath &> /dev/null; then
    OVERTAKE_DIR="$(realpath "$BASH_SOURCE")"
  else
    OVERTAKE_DIR="$BASH_SOURCE"
    echo "Command realpath from Coreutils not found. Assuming overtake is installed at $OVERTAKE_DIR, but if symlinks are used this may not be correct and you may need to set OVERTAKE_DIR in overtake.conf."
  fi
  OVERTAKE_DIR="${OVERTAKE_DIR%/*}"
fi

# Remove any trailing slash
PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR%/}"

[ -d "$PASSWORD_STORE_DIR" ] || error "No directory at $PASSWORD_STORE_DIR"

mode="$1"

case $mode in
  add)
    if [ $# -ne 2 ]; then
      echo "Error: Expected file argument"
      usage
    fi
    add "$2"
  ;;
  edit)
    case $# in
      1) edit ;;
      2) edit "$2" ;;
      *) usage ;;
    esac
  ;;
  delete)
     case $# in
      1) delete ;;
      2) delete "$2" ;;
      *) usage ;;
    esac
  ;;
  list)
    case $# in
      1) list_pretty_paths ;;
      2)
        if [ "$2" = "--full" ]; then
          list_absolute_paths
        elif [ "$2" = "--tree" ]; then
          list_tree
        else
          list_pretty_paths
        fi
      ;;
      *) usage ;;
    esac
  ;;
  show)
    case $# in
      1) show ;;
      2) show "$2" ;;
      *) usage ;;
    esac
  ;;
  copy)
    case $# in
      1) copy ;;
      2) copy "$2" ;;
      *) usage ;;
    esac
  ;;
  help)
    help
  ;;
  *)
    usage
  ;;
esac

