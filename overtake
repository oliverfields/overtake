#!/bin/bash

# Manage gpg encrypted files directory tree

# Halt on error
set -e


# Print error message and exit
error()
{
  msg="$1"
  exit_code="$2"

  echo -e "Error: $1" >&2

  [ "$exit_code" = "" ] && exit_code=1

  exit $exit_code
}


# Print help
help()
{
  echo -e 'Manage directory of GPG encrypted files and optionally any git repositories in the vault directory.

The argument [file] is optional, if not specified a file selection dialogue will be opened.

	\e[1madd\e[0m <file> [-|/dev/stdin]
		Create new file in $OVERTAKE_VAULT_DIR, path must be relative (not start with /). If path contains directories, these will also be created. Specifying - or /dev/stdin will read contents of stdin into editor(vim) for editing and before encrypting

		\e[1mExamples\e[0m
			$ overtake add gnupg.org/login

			Creates $OVERTAKE_VAULT_DIR/gnupg.org directory if not already created, and login.gpg encrypted file

			$ xkcdpass | overtake add login -

			Pipes output of xkcdpass to editor, and on save writes encrypted content to $OVERTAKE_VAULT_DIR/login.gpg

	\e[1mgit\e[0m [--commit-push-all|--pull-all]
		Manually trigger git commands

		--commit-push-all
			Commit all changes to git repositories in vault

		--list-repositories
			List git repositories in vault

		--pull-all
			Manually trigger pulls on all git repositories in vault

	\e[1medit\e[0m [file]
		Decrypt file, open in vi for editing and encrypt contents back to <file>

	\e[1mlist\e[0m [--absolute|--pretty]
		List .gpg files in $OVERTAKE_VAULT_DIR, defaults to tree view

		--absoulte
			Lists full paths

		--pretty
			Lists vault relative and pretty paths

	\e[1mrecipients\e[0m [--sync]
		List recipients for vault .gpg files. Recipients space separated and set in .gpg-id files, in config using setting recipients or by environment variable OVERTAKE_RECIPIENTS

		--sync
			Update recipients to match those specified. If new gpg key, a sync must be run

	\e[1mshow\e[0m <-copy|-c|--no-clear|-n> <file>
		Default select file from list and print decrypted contents to terminal

		--copy, -c
			Copy decrypted file to clipboard

		--no-clear, -n
			Disable clear screen prompt

	\e[1mhelp\e[0m
		This text
' | fmt

  usage
}

# Print usage message
usage()
{
  echo -e "Usage: overtake [file]
	add <file> [-|/dev/stdin]
	edit [file]
	git [--commit-push-all|--list-repositories|--pull-all]
	help
	list [--absolute|--pretty]
	recipients [--sync]
    show [-copy|--no-clear] [file]"
  exit 1
}


# For all git repositories in vault, run batch commands
batch_repos_cmd()
{
  # If git mode we want to git, so only honor sync git setting if another mode
  if [ "$mode" != "git" ]; then
    if [ "$OVERTAKE_SYNC_GIT" != "yes" ]; then
      return
    fi
  fi

  if ! command -v git &> /dev/null; then
      error "git command not found"
  fi

  batch_cmd="$1"

  # Check args
  if [ "$batch_cmd" != "pull" ] && [ "$batch_cmd" != "commitall" ]; then
    error "No valid batch command supplied for batch_command_repos $batch_cmd"
  fi


  # Find all git repos in vault
  for repo in $(find "$OVERTAKE_VAULT_DIR" -type d -name '.git'); do


    git_dir="${repo%/*}"

    cd "$git_dir" || error "Unable to cd to $git_dir"

    if [[ $(git branch -r) ]]; then
      has_remote="yes"
    else
      has_remote="no"
    fi

    case $batch_cmd in
      pull)
        if [ "$has_remote" = "yes" ]; then
          echo "Git pull $git_dir"
          git pull --quiet || error "Unable to pull repo $repo remote"
        fi
      ;;
      commitall)
        # Check if changes, if so commit and push
        if [ -n "$(git status --porcelain)" ]; then
          echo "Git commit on $git_dir"
          git add --all || error "Git add failed on repo $repo"
          git commit -m 'Overtake sync' --quiet || error "Git commit failed on repo $repo"

          if [ "$has_remote" = "yes" ]; then
            echo "Git push on $git_dir"
            git push --quiet || error "Unable to push to remote git repo $repo"
          fi
        fi
      ;;
    esac
  done
}


# Return absolute file path for a file
absolute_file_path()
{
  file_path="$1"

  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # If file path does not start with a / it is relative and needs making absolute
  if [[ "$file_path" != /* ]]; then
    file_path="$OVERTAKE_VAULT_DIR/$file_path"
  fi

  echo "$file_path"
}


# Return file path relative to vault dir for a file
relative_file_path()
{
  file_path="$1"
  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # Strip password dir
  file_path="${file_path#"$OVERTAKE_VAULT_DIR"/}"

  echo "$file_path"
}


# List all gpg files in vault
list_pretty_paths()
{
  list_absolute_paths | sed 's#^'$OVERTAKE_VAULT_DIR'/## ; s/\.gpg$//'
}


list_absolute_paths()
{
  find "$OVERTAKE_VAULT_DIR" -type f -name '*.gpg'
}


# List as tree
list_tree()
{
  if command -v tree &> /dev/null; then
    tree --noreport --dirsfirst "$OVERTAKE_VAULT_DIR" | sed 's/\.gpg$//'
  else
    echo "Warning: Command tree not found so doing a plain list instead" > /dev/stderr
    list_pretty_paths
  fi
}


list_git_repos()
{
  for repo in $(find "$OVERTAKE_VAULT_DIR" -type d -name '.git'); do
    cd "${repo%/.git}"
    echo "$PWD/.git $(git ls-remote --get-url origin)"
  done | sort
}


# Re-encrypt all gpg fiels with configured recipients
sync_recipients()
{
  # Tmp file will always contain encrypted data, but if paranoid maybe not put in tmp directory?
  tmp_file="$(mktemp)"

  trap "rm -f '$tmp_file'" EXIT

  for file in $(find "$OVERTAKE_VAULT_DIR" -type f -name '*.gpg'); do
    recipients="$(get_configured_recipients "$file")"
    recipients="--recipient ${recipients// / --recipient }"

    gpg --quiet --decrypt "$file" | gpg --yes --quiet $recipients --output "$tmp_file" --encrypt

    mv "$tmp_file" "$file"
  done
}


# List each file. For each file flag if configured recipients does not match actual gpg file recipuients
list_recipients()
{

  for file in $(find "$OVERTAKE_VAULT_DIR" -type f -name '*.gpg' | sort); do
    actual_recipients="$(get_gpg_file_recipients "$file")"
    configured_recipients="$(get_configured_recipients "$file")"

    [ "$actual_recipients" = "" ] && error "No recipients found in $file"
    [ "$configured_recipients" = "" ] && error "No recipients configured for $file"

    file_name="${file#$OVERTAKE_VAULT_DIR/}"
    file_name="${file_name%.gpg}"

    # Checking actual and configured are the same depends on both functions return recipients alphabetically sorted
    if [ "$actual_recipients" = "$configured_recipients" ]; then
      echo "$file_name: $actual_recipients"
    else
      echo "$file_name Warning: actual recipients ($actual_recipients) do not match configured recipients ($configured_recipients) run overtake recipients --sync to re-encrypt using configured recipients"
    fi
  done
}


# Get actual recipients that can decode a gpg file
get_gpg_file_recipients()
{
  local file="$1"
  recipients=""

  gpg --decrypt --list-only --keyid-format long "$file" 2>&1 \
  | while read -r line; do
    if [[ "$line" == gpg:* ]]; then
      :
    elif [[ "$line" == 	* ]]; then
      recipient="${line#*<}"
      recipient="${recipient%>\"}"
      echo "$recipient"
    fi
  done | sort | tr '\n' ' ' | sed 's/\ $//'
}


# Get all configured recipients from .gpg-id files, $OVERTAKE_RECIPIENTS
# Veryfi have gpg key available for each recipient
get_configured_recipients()
{
  file="$1"
  dir_path="${file%/*}"
  gpg_id_file=""

  cd "$dir_path"

  # Go up directory tree until find a valid .gpg-id file, quit if we gone passed the vault
  while [ "$PWD" != "${OVERTAKE_VAULT_DIR%/*}" ]; do
    if [ -f "$PWD/.gpg-id" ]; then
      gpg_id_file="$PWD/.gpg-id"
      break
    fi
    cd ..
  done

  if [ "$gpg_id_file" != "" ]; then
    recipients_string=$(paste -s -d ' ' "$gpg_id_file")
  fi

  # Add recipients from settings also
  recipients_string="$OVERTAKE_RECIPIENTS $recipients_string"
  recipients_string="${recipients_string/  / }"

  # Need to tidy up, remove any duplicates and verify that have recipient keys
  recipients_tmp_array=( $recipients_string )

  [ ${#recipients_tmp_array[@]} -eq 0 ] && error "No gpg recipients defined in OVERTAKE_DEFAULT_RECIPIENTS or .gpg-id files"

  # Use associative array to weed out duplicates
  declare -A recipients
  for r in "${recipients_tmp_array[@]}"; do
    recipients["$r"]="NULL"
  done

  missing_keys=()

  # Check we have gpg public keys for the recipients
  for key in "${!recipients[@]}"; do
    if gpg --list-keys "$key" &> /dev/null; then
      recipients[$key]="yes"
    else
      recipients[$key]="no"
      missing_keys+=($key)
    fi
  done


  if [ ${#missing_keys[@]} -ne 0 ]; then
    missing_keys_string="${missing_keys[@]}"
    missing_keys_string="${missing_keys_string// /, }"
    error "No public keys match $missing_keys_string, unable to process $file"
  fi

  for key in "${!recipients[@]}"; do
    echo "$key"
  done | sort | tr '\n' ' ' | sed 's/\ $//'
}


# Try to add new encrypted file with newly generated passphrase, update git if applicable
add()
{
  # If path contains OVERTAKE_VAULT_DIR, remove it, so we can handle both relative and absolute paths
  file="$1"
  pipe_input="$2"

  file_path_absolute="$(absolute_file_path "$file")"
  file_path_relative="$(relative_file_path "$file")"

  [ -e "$file_path_absolute" ] && error "Unable to create $file_path_absolute, it already exists"

  # Create directories if need be
  # TODO trap ERR to delete dirs if things go south
  file_directories="${file_path_absolute%/*}"
  mkdir -p "$file_directories" || error "Unable to create $file_directories"

  gpg_recipients="$(get_configured_recipients "$file_path_absolute")"

  if [ "$pipe_input" = "-" ]; then
    cmd="gpg --encrypt --out \"$file_path_absolute\" --recipient \"${gpg_recipients// /\" --recipient \"}\" -"
    eval "$cmd"
  elif [[ $(type -t OVERTAKE_EXT_template) == function ]]; then
    OVERTAKE_EXT_template | edit_then_encrypt "$file_path_absolute" "$gpg_recipients" "-"
  else
      edit_then_encrypt "$file_path_absolute" "$gpg_recipients"
  fi
}


# Decrypt, edit and reencrypt file, file passed as argument or selected from fzf
edit()
{
  file="$(get_file_path "$1")"

  [ "$file" = "" ] && exit 0

  gpg_recipients="$(get_configured_recipients "$file")"

  gpg_decrypt_file "$file" | edit_then_encrypt "$file" "$gpg_recipients" "-"
}


# Allow user to edit data and save it encrypted to disk
# Must be callable in two ways
# 1. With path to save data to and the recipients (CSV if multiple) to encrypt to
#    E.g edit_then_encrypt "/tmp/myfile.gpg" "your@email.com,another@email.com"
# 2. With the path to save to, recipients andand "-" indicating stdin, and data piped into the funtion
#    E.g echo "My content" | edit_then_encrypt "/tmp/myfile.gpg" "me@you.com" "-"
edit_then_encrypt()
{
  save_path="$1"
  recipients="$2"
  stdin_arg="$3"

  if [ "$stdin_arg" = "-" ]; then
    readarray -u 0 stdin

    printf "%s" "${stdin[@]}" | GPG_RECIPIENTS="$recipients" GPG_ENCRYPTED_FILE="$save_path" vim --not-a-term -u "$OVERTAKE_VIMRC" -
  else
    GPG_RECIPIENTS="$recipients" GPG_ENCRYPTED_FILE="$save_path" vim --not-a-term -u "$OVERTAKE_VIMRC"
  fi
}


# Take path and make it absolute, if no path get user to choose
get_file_path()
{
  file="$1"

  if [ "$2" = "" ]; then
    prompt="vault $OVERTAKE_VAULT_DIR using key $OVERTAKE_RECIPIENTS"
  else
    prompt="$2"
  fi

  # If no argument, get user to select a file to edit
  if [ "$file" = "" ]; then
    file="$(list_pretty_paths | fzf "--header=$prompt" --exact)"
    [ "$file" = "" ] && return 0
  fi

  file_path_absolute="$(absolute_file_path "$file")"

  [ -f "$file_path_absolute" ] || error "Path $file not found"

  echo "$file_path_absolute"
}


# Print decrypted content
print_decrypted_content()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  gpg_decrypt_file "$file"
}

# Decrypt and show to user either in terminal or via clipboard
show()
{
  local option="notset"

  case $# in
    0) file="" ;;
    1)
      # Is first arg a file or an option
      if [[ "$1" =~ ^(--no-clear|-n|--copy|-c)$ ]]; then
        option="$1"
        file="$2"
      else
        file="$1"
      fi
    ;;
    2)
      option="$1"
      file="$2"
    ;;
    *) usage ;;
  esac

  # Default, print decrypted content to terminal
  if [ "$option" = "notset" ] || [ "$option" = "--no-clear" ] || [ "$option" = "-n" ]; then
    print_decrypted_content "$file"

    # Unless disabled, show prompt to clear terminal
    if [ "$option" = "notset" ]; then
      echo ""
      read -p "Press any key to clear terminal and continue.." key
      clear
    fi
  elif [ "$option" = "--copy" ] || [ "$option" = "-c" ]; then
    # If config file has defined a function for clipboard, use it to copy
    if [[ $(type -t OVERTAKE_EXT_clipboard) == function ]]; then
      print_decrypted_content "$file" | OVERTAKE_EXT_clipboard
    # Else emulate pass behaviour by just copying 1st line to clipboard
    else
      print_decrypted_content "$file" | head -n1 | tr -d '\n' | xsel --clipboard
    fi 
  else
    usage
  fi
}


gpg_decrypt_file()
{
  file="$1"
  [ -e "$file" ] || error "File $file not found, unable to decrypt"
  gpg --quiet --decrypt "$file" || error "Unable to decrypt $file, perhaps key passphrase is not cached by gpg-agent yet?"
}


# Thanks MrYellow https://unix.stackexchange.com/a/721679
OVERTAKE_DIR=$( cd -- "$( dirname -- "$(readlink -f "${BASH_SOURCE[0]}" || ${BASH_SOURCE[0]})" )" &> /dev/null && pwd )

config_file="$HOME/.config/overtake.conf"

# Load config
if [ -e "$config_file" ]; then
  while read -r line; do

    # Skip comments and blank lines
    [[ "$line" =~ ^# ]] && continue
    [[ "$line" =~ ^\ *$ ]] && continue

    # Expand home directory
    line="${line/\~/$HOME}"
    line="${line/\$HOME/$HOME}"

    case $line in
      vault_dir=*) [ -z "$OVERTAKE_VAULT_DIR" ] && OVERTAKE_VAULT_DIR="${line#vault_dir=}" ;;
      recipients=*) [ -z "$OVERTAKE_RECIPIENTS" ] && OVERTAKE_RECIPIENTS="${line#recipients=}" ;;
      sync_git=*) [ -z "$OVERTAKE_SYNC_GIT" ] && OVERTAKE_SYNC_GIT="${line#sync_git=}" ;;
      vimrc_overtake=*) [ -z "$OVERTAKE_VIMRC" ] && OVERTAKE_VIMRC="${line#vimrc_overtake=}" ;;
      overtake_extensions=*) [ -z "$OVERTAKE_EXTENSIONS" ] && OVERTAKE_EXTENSIONS="${line#overtake_extensions=}" ;;
      *)
        echo "Warning: Unknown setting $line in $config_file"
      ;;
    esac
  done < "$config_file"
fi

# Set defaults if no environment variables found or values not set in config file
[ -z "$OVERTAKE_VAULT_DIR" ] && OVERTAKE_VAULT_DIR="$HOME/.secrets"
[ -z "$OVERTAKE_RECIPIENTS" ] && OVERTAKE_RECIPIENTS="your@gpg.key"
[ -z "$OVERTAKE_SYNC_GIT" ] && OVERTAKE_SYNC_GIT="no"
[ -z "$OVERTAKE_VIMRC" ] && OVERTAKE_VIMRC="$OVERTAKE_DIR/vimrc_overtake"
[ -z "$OVERTAKE_EXTENSIONS" ] && OVERTAKE_EXTENSIONS="$OVERTAKE_DIR/extensions.sh"

# Load extensions
[ -e "$OVERTAKE_EXTENSIONS" ] && source "$OVERTAKE_EXTENSIONS"

# Remove any trailing slash
OVERTAKE_VAULT_DIR="${OVERTAKE_VAULT_DIR%/}"

[ -d "$OVERTAKE_VAULT_DIR" ] || error "No directory at $OVERTAKE_VAULT_DIR"

# Set mode
if [ $# -eq 0 ]; then
  mode="show"
else
  mode="$1"
fi

# When to do git pull
case $mode in
  help|git) : ;; # Do nothing
  *) batch_repos_cmd pull ;;
esac


case $mode in
  add)
    case $# in
      1) usage ;;
      2) add "$2" ;;
      3)
        if [ "$3" = "-" ] || [ "$3" = "/dev/stdin" ]; then
          add "$2" "-"
        else
          usage
        fi
      ;;
      *) usage ;;
    esac
  ;;
  edit)
    case $# in
      1) edit ;;
      2) edit "$2" ;;
      *) usage ;;
    esac
  ;;
  list)
    case $# in
      1) list_tree ;;
      2)
        case $2 in
          --absolute) list_absolute_paths ;;
          --pretty) list_pretty_paths ;;
          *) usage ;;
        esac
      ;;
      *) usage ;;
    esac
  ;;
  recipients)
     case $# in
      1) list_recipients ;;
      2)
        if [ "$2" = "--sync" ]; then
          sync_recipients
        else
          usage
        fi
      ;;
      *) usage ;;
    esac
  ;;
  show)
    case $# in
      0|1) show ;;
      2) show "$2" ;;
      3) show "$2" "$3" ;;
      *) usage ;;
    esac

  ;;
  git)
    case $# in
      1) list_git_repos ;;
      2)
        case $2 in
          --pull-all) batch_repos_cmd pull ;;
          --commit-push-all) batch_repos_cmd commitall ;;
          --list-repositories) list_git_repos ;;
          *) usage ;;
        esac
      ;;
      *) usage ;;
    esac
  ;;
  help)
    help
  ;;
  *)
    if [ $# -eq 1 ]; then
      path="$(absolute_file_path "$1")"
      if [ -f "$path" ]; then
        show "$path"
      else
        usage
      fi
    else
      usage
    fi
  ;;
esac


# When to do git commit
case $mode in
  git|help|list|show|copy) : ;; # Do nothing
  *) batch_repos_cmd commitall ;;
esac
