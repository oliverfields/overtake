#!/bin/bash

# Manage gpg encrypted files in pass .password-store type directory

# Halt on error
set -e


# Print error message and exit
error()
{
  msg="$1"
  exit_code="$2"

  echo -e "Error: $1" >&2

  [ "$exit_code" = "" ] && exit_code=1

  exit $exit_code
}


# Print help
help()
{
  echo -e 'Manage directory of GPG encrypted files and optionally any git repositories in the password store directory.

The argument [file] is optional, if not specified a file selection dialogue will be opened.

	\e[1madd\e[0m <file> [-|/dev/stdin]
		Create new file in $PASSWORD_STORE_DIR, path must be relative (not start with /). If path contains directories, these will also be created. Specifying - or /dev/stdin will read contents of stdin into editor(vim) for editing and before encrypting

		\e[1mExamples\e[0m
			$ overtake add gnupg.org/login

			Creates $PASSWORD_STORE_DIR/gnupg.org directory if not already created, and login.gpg encrypted file

			$ xkcdpass | overtake add login -

			Pipes output of xkcdpass to editor, and on save writes encrypted content to $PASSWORD_STORE_DIR/login.gpg

	\e[1mgit\e[0m [--commit-all|--pull-all]
		Manually trigger git commands

		--commit-all
			Commit all changes to git repositories in password store

		--list-repositories
			List git repositories in password store

		--pull-all
			Manually trigger pulls on all git repositories in password store

	\e[1mcopy\e[0m [file]
		Copies decrypted contents to clipboard

	\e[1mdelete\e[0m [file]
		Deletes file from $PASSWORD_STORE_DIR

	\e[1medit\e[0m [file]
		Decrypt file, open in vi for editing and encrypt contents back to <file>

	\e[1mlist\e[0m [--absolute|--pretty]
		List .gpg files in $PASSWORD_STORE_DIR, defaults to tree view

		--absoulte
			Lists full paths

		--pretty
			Lists password store relative and pretty paths

	\e[1mrecipients\e[0m [--sync]
		List recipients for password store .gpg files. Recipients space separated and set in .gpg-id files, in config using setting recipients or by environment variable OVERTAKE_RECIPIENTS

		--sync
			Update recipients to match those specified. If new gpg key, a sync must be run

	\e[1mshow\e[0m [file]
		Print decrypted file to terminal

	\e[1mhelp\e[0m
		This text
' | fmt

  usage
}

# Print usage message
usage()
{
  echo -e "Usage: overtake [add <file> [-|/dev/stdin]|copy [file]|delete [file]|edit [file]|git [--commit-all|--list-repositories|--pull-all]|help|list [--absolute|--pretty]|recipients [--sync]|show [file]]"
  exit 1
}


# For all git repositories in password store, run batch commands
batch_repos_cmd()
{
  if [ "$OVERTAKE_SYNC_GIT" != "yes" ]; then
    return
  fi

  if ! command -v git &> /dev/null; then
      error "git command not found"
  fi

  batch_cmd="$1"

  # Check args
  if [ "$batch_cmd" != "pull" ] && [ "$batch_cmd" != "commitall" ]; then
    error "No valid batch command supplied for batch_command_repos $batch_cmd"
  fi


  # Find all git repos in password store
  for repo in $(find "$PASSWORD_STORE_DIR" -type d -name '.git'); do

    git_dir="${repo%/*}"

    cd "$git_dir" || error "Unable to cd to $git_dir"

    if [[ $(git branch -r) ]]; then
      has_remote="yes"
    else
      has_remote="no"
    fi

    case $batch_cmd in
      pull)
        if [ "$has_remote" = "yes" ]; then
          git pull --quiet || error "Unable to pull repo $repo remote"
        fi
      ;;
      commitall)
        # Check if changes, if so commit and push
        if [ -n "$(git status --porcelain)" ]; then
          git add --all || error "Git add failed on repo $repo"
          git commit -m 'Overtake sync' --quiet || error "Git commit failed on repo $repo"

          if [ "$has_remote" = "yes" ]; then
            git push --quiet || error "Unable to push to remote git repo $repo"
          fi
        fi
      ;;
    esac
  done
}


# Return absolute file path for a file
absolute_file_path()
{
  file_path="$1"

  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # If file path does not start with a / it is relative and needs making absolute
  if [[ "$file_path" != /* ]]; then
    file_path="$PASSWORD_STORE_DIR/$file_path"
  fi

  echo "$file_path"
}


# Return file path relative to password store dir for a file
relative_file_path()
{
  file_path="$1"
  # Cut of .gpg extension if exists, and pop it back on, so we can handle with or without
  file_path="${file_path%.gpg}.gpg"

  # Strip password dir
  file_path="${file_path#"$PASSWORD_STORE_DIR"/}"

  echo "$file_path"
}


# List all gpg files in password store
list_pretty_paths()
{
  list_absolute_paths | sed 's#^'$PASSWORD_STORE_DIR'/## ; s/\.gpg$//'
}


list_absolute_paths()
{
  find "$PASSWORD_STORE_DIR" -type f -name '*.gpg'
}


# List as tree
list_tree()
{
  if command -v tree &> /dev/null; then
    tree --noreport --dirsfirst "$PASSWORD_STORE_DIR" | sed 's/\.gpg$//'
  else
    echo "Warning: Command tree not found so doing a plain list instead" > /dev/stderr
    list_pretty_paths
  fi
}


list_git_repos()
{
  for repo in $(find "$PASSWORD_STORE_DIR" -type d -name '.git'); do
    cd "${repo%/.git}"
    echo "$PWD/.git $(git ls-remote --get-url origin)"
  done | sort
}


list_recipients()
{
  for encfile in $(find "$PASSWORD_STORE_DIR" -type f -name '*.gpg' | sort); do

    echo -n "${encfile#$PASSWORD_STORE_DIR/}"

    gpg --decrypt --list-only --keyid-format long "$encfile" 2>&1 \
    | while read -r line; do
      if [[ "$line" == gpg:* ]]; then
        :
        #key_id="${line##* ID }"
        #key_id="${key_id%,*}"

        #echo -n " $key_id"
      elif [[ "$line" == 	* ]]; then
        echo -n " $line"
      fi
    done | sed 's/"[^"]*<//g ; s/>"//g ; s/$/\n/'
  done
}


# Try to add new encrypted file with newly generated passphrase, update git if applicable
add()
{
  # If path contains PASSWORD_STORE_DIR, remove it, so we can handle both relative and absolute paths
  file="$1"
  pipe_input="$2"

  file_path_absolute="$(absolute_file_path "$file")"
  file_path_relative="$(relative_file_path "$file")"

  [ -e "$file_path_absolute" ] && error "Unable to create $file_path_absolute, it already exists"

  # Create directories if need be
  # TODO trap ERR to delete dirs if things go south
  file_directories="${file_path_absolute%/*}"
  mkdir -p "$file_directories" || error "Unable to create $file_directories"

  gpg_recipients="$(get_gpg_recipients "$file_path_absolute")"

  if [[ $(type -t OVERTAKE_EXT_template) == function ]]; then
    if [ "$pipe_input" = "-" ]; then
      OVERTAKE_EXT_template "-" < /dev/stdin | edit_then_encrypt "$file_path_absolute" "$gpg_recipients" "-"
    else
      OVERTAKE_EXT_template | edit_then_encrypt "$file_path_absolute" "$gpg_recipients" "-"
    fi
  else
    if [ "$pipe_input" = "-" ]; then
echo hi
      edit_then_encrypt "$file_path_absolute" "$gpg_recipients" "-" < /dev/stdin
    else
echo hii
      edit_then_encrypt "$file_path_absolute" "$gpg_recipients"
    fi
  fi
}


# Decrypt, edit and reencrypt file, file passed as argument or selected from fzf
edit()
{
  file="$(get_file_path "$1")"

  [ "$file" = "" ] && exit 0

  gpg_recipients="$(get_gpg_recipients "$file")"

  gpg_decrypt_file "$file" | edit_then_encrypt "$file" "$gpg_recipients" "-"
}


# Allow user to edit data and save it encrypted to disk
# Must be callable in two ways
# 1. With path to save data to and the recipients (CSV if multiple) to encrypt to
#    E.g edit_then_encrypt "/tmp/myfile.gpg" "your@email.com,another@email.com"
# 2. With the path to save to, recipients andand "-" indicating stdin, and data piped into the funtion
#    E.g echo "My content" | edit_then_encrypt "/tmp/myfile.gpg" "me@you.com" "-"
edit_then_encrypt()
{
  save_path="$1"
  recipients="$2"
  stdin_arg="$3"

  if [ "$stdin_arg" = "-" ]; then
    GPG_RECIPIENTS="$recipients" GPG_ENCRYPTED_FILE="$save_path" vim --not-a-term -u "$OVERTAKE_VIMRC" - < /dev/stdin
  else
    GPG_RECIPIENTS="$recipients" GPG_ENCRYPTED_FILE="$save_path" vim --not-a-term -u "$OVERTAKE_VIMRC"
  fi
}


# Given a path look up until find a .gpg-id file, this contains the recipients, one per line
get_gpg_recipients()
{
  file="$1"
  dir_path="${file%/*}"
  gpg_id_file=""

  cd "$dir_path"

  # Go up directory tree until find a valid .gpg-id file, quit if we gone passed the password store
  while [ "$PWD" != "${PASSWORD_STORE_DIR%/*}" ]; do
    if [ -f "$PWD/.gpg-id" ]; then
      gpg_id_file="$PWD/.gpg-id"
      break
    fi
    cd ..
  done

  if [ "$gpg_id_file" != "" ]; then
    recipients_string=$(paste -s -d ' ' "$gpg_id_file")
  fi

  # Add recipients from settings also
  recipients_string="$OVERTAKE_RECIPIENTS $recipients_string"
  recipients_string="$PASSWORD_STORE_KEY $recipients_string"

  # Need to tidy up, remove any duplicates and verify that have recipient keys
  recipients_tmp_array=( $recipients_string )

  [ ${#recipients_tmp_array[@]} -eq 0 ] && error "No gpg recipients defined in PASSWORD_STORE_DIR_DEFAULT_RECIPIENTS, .gpg-id files or PASSWORD_STORE_KEY"

  # Use associative array to weed out duplicates
  declare -A recipients
  for r in "${recipients_tmp_array[@]}"; do
    recipients["$r"]="NULL"
  done

  missing_keys=()

  # Check we have gpg public keys for the recipients
  for key in "${!recipients[@]}"; do
    if gpg --list-keys "$key" &> /dev/null; then
      recipients[$key]="yes"
    else
      recipients[$key]="no"
      missing_keys+=($key)
    fi
  done


  if [ ${#missing_keys[@]} -ne 0 ]; then
    missing_keys_string="${missing_keys[@]}"
    missing_keys_string="${missing_keys_string// /, }"
    error "No public keys match $missing_keys_string, unable to process $file"
  fi

  recipient_keys=""
  for key in "${!recipients[@]}"; do
    recipient_keys="$recipient_keys $key"
  done
  recipient_keys="${recipient_keys# }"

  echo -n "$recipient_keys"
}


# Take path and make it absolute, if no path get user to choose
get_file_path()
{
  file="$1"

  if [ "$2" = "" ]; then
    prompt="Password store $PASSWORD_STORE_DIR using key $OVERTAKE_RECIPIENTS"
  else
    prompt="$2"
  fi

  # If no argument, get user to select a file to edit
  if [ "$file" = "" ]; then
    file="$(list_pretty_paths | fzf "--header=$prompt" --exact)"
    [ "$file" = "" ] && return 0
  fi

  file_path_absolute="$(absolute_file_path "$file")"

  [ -f "$file_path_absolute" ] || error "Path $file not found"

  echo "$file_path_absolute"
}


# Print decrypted content
print_decrypted_content()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  gpg_decrypt_file "$file"
}


show()
{
  print_decrypted_content "$1"
  echo ""
  read -p "Press any key to clear terminal and continue.." key
  clear
}


# Delete key
delete()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  [ -e "$file" ] || error "File $file does not exist"

  rm "$file"
}


# Copy key to clipboard
copy()
{
  file="$(get_file_path "$1")"

  # No file selected
  [ "$file" = "" ] && exit 0

  # If config file has defined a function for clipboard, use it to copy
  if [[ $(type -t OVERTAKE_EXT_clipboard) == function ]]; then
    print_decrypted_content "$file" | OVERTAKE_EXT_clipboard
  # Else emulate pass behaviour by just copying 1st line to clipboard
  else
    print_decrypted_content "$file" | head -n1 | tr -d '\n' | xsel --clipboard
  fi
}


gpg_decrypt_file()
{
  file="$1"
  [ -e "$file" ] || error "File $file not found, unable to decrypt"
  gpg --quiet --decrypt "$file" || error "Unable to decrypt $file, perhaps key passphrase is not cached by gpg-agent yet?"
}


# Exit if no args
[ $# -lt 1 ] && usage

# Thanks MrYellow https://unix.stackexchange.com/a/721679
OVERTAKE_DIR=$( cd -- "$( dirname -- "$(readlink -f "${BASH_SOURCE[0]}" || ${BASH_SOURCE[0]})" )" &> /dev/null && pwd )

config_file="$HOME/.config/overtake.conf"

# Load config
if [ -e "$config_file" ]; then
  while read -r line; do

    # Skip comments and blank lines
    [[ "$line" =~ ^# ]] && continue
    [[ "$line" =~ ^\ *$ ]] && continue

    # Expand home directory
    line="${line/\~/$HOME}"
    line="${line/\$HOME/$HOME}"

    case $line in
      password_store_dir=*) [ -z "$PASSWORD_STORE_DIR" ] && PASSWORD_STORE_DIR="${line#password_store_dir=}" ;;
      recipients=*) [ -z "$OVERTAKE_RECIPIENTS" ] && OVERTAKE_RECIPIENTS="${line#recipients=}" ;;
      sync_git=*) [ -z "$OVERTAKE_SYNC_GIT" ] && OVERTAKE_SYNC_GIT="${line#sync_git=}" ;;
      vimrc_overtake=*) [ -z "$OVERTAKE_VIMRC" ] && OVERTAKE_VIMRC="${line#vimrc_overtake=}" ;;
      overtake_extensions=*) [ -z "$OVERTAKE_EXTENSIONS" ] && OVERTAKE_EXTENSIONS="${line#overtake_extensions=}" ;;
      *)
        echo "Warning: Unknown setting $line in $config_file"
      ;;
    esac
  done < "$config_file"
fi

# Set defaults if no environment variables found or values not set in config file
[ -z "$PASSWORD_STORE_DIR" ] && PASSWORD_STORE_DIR="$HOME/.password-store"
[ -z "$OVERTAKE_RECIPIENTS" ] && OVERTAKE_RECIPIENTS="your@gpg.key"
[ -z "$OVERTAKE_SYNC_GIT" ] && OVERTAKE_SYNC_GIT="no"
[ -z "$OVERTAKE_VIMRC" ] && OVERTAKE_VIMRC="$OVERTAKE_DIR/vimrc_overtake"
[ -z "$OVERTAKE_EXTENSIONS" ] && OVERTAKE_EXTENSIONS="$OVERTAKE_DIR/extensions.sh"

# Load extensions
[ -e "$OVERTAKE_EXTENSIONS" ] && source "$OVERTAKE_EXTENSIONS"

# Remove any trailing slash
PASSWORD_STORE_DIR="${PASSWORD_STORE_DIR%/}"

[ -d "$PASSWORD_STORE_DIR" ] || error "No directory at $PASSWORD_STORE_DIR"

mode="$1"

# Git pull
case $mode in
  help)
    : # Do nothing
  ;;
  git)
    # If we are using git mode, we are of course syncing
    OVERTAKE_SYNC_GIT=yes batch_repos_cmd pull
  ;;
  *)
    batch_repos_cmd pull
  ;;
esac


case $mode in
  add)
    case $# in
      1) usage ;;
      2) add "$2" ;;
      3)
        if [ "$3" = "-" ] || [ "$3" = "/dev/stdin" ]; then
          add "$2" "-"
        else
          usage
        fi
      ;;
      *) usage ;;
    esac
  ;;
  edit)
    case $# in
      1) edit ;;
      2) edit "$2" ;;
      *) usage ;;
    esac
  ;;
  delete)
     case $# in
      1) delete ;;
      2) delete "$2" ;;
      *) usage ;;
    esac
  ;;
  list)
    case $# in
      1) list_tree ;;
      2)
        case $2 in
          --absolute) list_absolute_paths ;;
          --pretty) list_pretty_paths ;;
          *) usage ;;
        esac
      ;;
      *) usage ;;
    esac
  ;;
  recipients)
     case $# in
      1) list_recipients ;;
      2)
        if [ "$2" = "--sync" ]; then
          echo IMPLEMENT ME TODO
        else
          usage
        fi
      ;;
      *) usage ;;
    esac
  ;;

  show)
    case $# in
      1) show ;;
      2) show "$2" ;;
      *) usage ;;
    esac
  ;;
  copy)
    case $# in
      1) copy ;;
      2) copy "$2" ;;
      *) usage ;;
    esac
  ;;
  git)
    if [ "$2" = "--pull-all" ] || [ "$2" = "--commit-all" ]; then
      # Actions are called before and after this case, so our work here is already done
      :
    elif [ "$2" = "--list-repositories" ]; then
      list_git_repos
    else
      usage
    fi
  ;;
  help)
    help
  ;;
  *)
    usage
  ;;
esac


# Git commit
case $mode in
  help|list)
    : # Do nothing
  ;;
  git)
    # If we are using git mode, we are of course syncing
    OVERTAKE_SYNC_GIT=yes batch_repos_cmd commitall
  ;;
  *)
    batch_repos_cmd commitall
  ;;
esac
